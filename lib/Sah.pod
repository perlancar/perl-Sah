package Sah; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Schema for data structures (specification)

=head1 SPECIFICATION VERSION

0.9

=head1 STATUS

In the 0.9.0 series, there will probably still be incompatible syntax changes
between revision before the spec stabilizes into 1.0 series.


=head1 OVERVIEW

This document specifies Sah, a schema language for validating data structures.
Some features of this schema language:

=over 4

=item * Written as data structure

A Sah schema is just a normal data structure. Using data structures as schemas
simplifies parsing and enables easier manipulation (composition, merging, etc)
of schemas as well validation of the schemas themselves.

=item * Emphasis on reusability

A schema can be defined in terms of (based of) other schemas. An example:

 # schema: even (even numbers)
 [int => {div_by=>2}]

 # schema: pos_even (positive even numbers)
 [even => {min=>0}]

In the above example, C<pos_even> is defined in terms of C<even> with an
additional clause (C<< min=>0 >>). As a matter of fact you can also override and
B<remove> clauses from your base schema, for even more flexibility.

 # schema: pos_even_or_odd (positive even or odd numbers)
 [pos_even => {"[merge!]div_by"=>2}] # remove the div_by clause

The above example makes C<pos_even_or_odd> effectively equivalent to positive
integer.

For schema-local definition, you can also define schemas within schemas:

 # dice_throws: array of dice throw results
 ["array*" => {of => 'dice_throw*'},
  {def => {
      dice_throw => [int => {between=>[1, 6]}],
  }},
 ]

The C<dice_throw> schema will only be visible from within the C<dice_throws>.

=back


=head1 TERMINOLOGY

Although it can contain extra stuffs, a B<schema> is essentially a type
definition, stating a set of valid values for data. Sah defines several basic
types like "bool", "int", "str", "array", "hash", and a few others.

A type can have B<clauses>, which mostly declare constraints. When validating
data each clause will be tested and must succeed for the whole validation to
succeed (there are exceptions, but it is not important right now). Aside from
declaring constraints, clauses can also declare other stuff like default value
(the C<default> clause), store metadata (the C<summary>, C<description>, C<tags>
clauses), etc.

A B<Clause set> is just a set of clauses, written in a defhash (see L<DefHash>).
Defhash properties map to Sah clauses, while defhash property attributes map to
Sah clause attributes. A Sah schema is essentially comprised of type name and a
clause set.

B<Base schema>. You can define a schema, declare it as a new type, and then
write subsequent schemas against that type, along with additional clauses. This
is very much like subtyping. See L</"BASE SCHEMA"> for more information.


=head1 GENERAL STRUCTURE

Sah schema is an array:

 [TYPE_NAME, CLAUSE_SET, EXTRAS]

TYPE_NAME is a string and must be started by a letter/underscore and contain
only letters/numbers/underscores. CLAUSE_SET and EXTRAS are optional.

Examples:

 ['int']
 ['int', {min=>1, max=>10}]

If you don't have EXTRAS, you can also write it like this (saves a couple of
characters):

 ["int", min=>1, max=>10]

If you don't have any clauses, you can use the scalar/string form:

 "int"

EXTRAS is a hashref. Currently the only known key is B<def>, for defining base
schemas locally (see L</"BASE SCHEMA"> for more information). The other keys are
reserved for future use.

Text/strings should be in Unicode (UTF-8).

=head2 String form shortcuts

For convenience, the string form not only can be used to specify just type, but
also some common clauses via shortcut syntax:

=over 4

=item * The * suffix (req=>1)

 "X*"

is equivalent to:

 [X => {req=>1}]

=back


=head1 BASE SCHEMA

As mentioned before, you can define a schema as a type and then write other
schemas against that type. For example:

 # defined as pos_int type
 [int => {min=>0}]

and later:

 # a positive integer, divisible by 5
 [pos_int => {div_by=>5}]

During data validation, base schemas will be replaced by its original
definition, and all the clause sets will be evaluated. Illustrated by the plus
sign:

 [int => {min=>0} + {div_by=>5}]

You can also declare base schemas/types locally using the B<def> key in EXTRAS
(the third element of the array schema), for example:

 [throws => {},
  {
      def => {
          single_dice_throw  => [int => {in => [1,2,3,4,5,6]}],
          sdt                => "single_dice_throw", # short notation
          dice_pair_throw    => [array => {len=>2, elems=>["sdt", "sdt"]}],
          dpt                => "dice_pair_throw",   # short notation
          throw              => [any => {of => ["sdt", "dpt"]}],
          throws             => [array => {of => 'throw'}],
      },
  }
 ]

The above schema describes a list of dice throws ("throws"). Each B<throw> can
be a single dice throw ("sdt") which is a number between 1 and 6, OR a throw of
two dices ("dpt") which is a 2-element array (where each element is a number
between 1 and 6).

Examples of valid data for this schema:

 [1, [1,3], 6, 4, 2, [3,5]]

Examples of invalid data:

 1                  # not an array
 [1, [2, 3], 0]     # the third throw is invalid
 [1, [2, 0, 4], 4]  # the second throw is invalid

All the base schemas names "throw", "throws", "sdt", etc is only declared
locally and unknown outside the schema. You can even nest this.

=head2 Optional/conditional definition

If you put a C<?> suffix after the definition name then it means that the
definition is optional and can be skipped if the type is already defined, e.g.:

  def         => {
      "email?"   => [str => {req=>1, match=>".+\@.+"}],
      "username" => [str => {req=>1, match=>'^[a-z0-9_]+$'}],
  },

In the above example, if there is already an "email" type defined at that time,
the definition will be skipped instead of a "cannot redefine type" error being
generated.

Optional definition is useful if you want to provide some defaults (e.g. a
rudimentary validation for email) but don't mind if the validator already has
something probably better (a stricter or more precise definition of email).


=head1 CLAUSE

A clause set is a defhash containing clause name (as hash keys), clause value
(as hash value), and clause attribute names and values (as hash keys and
values):

mapping of clause attributes and its values:

 {
     'CLAUSENAME1' => CLAUSEVALUE,
     'CLAUSENAME1.ATTRNAME1' => ATTRVALUE1,
     'CLAUSENAME1.ATTRNAME2' => ATTRVALUE2,
     'CLAUSENAME1.ATTRNAME1.SUBATTR1' => ...,
     ...
     _IGNORED => ...,
     CLAUSENAME1._IGNORED => ...,
 }

For convenience, there are also some shortcuts:

=over 4

=item * C<&> suffix (multiple clause values, all must succeed)

 "CLAUSENAME&" => [VAL, ...]

is equivalent to:

 "CLAUSENAME.vals" => [VAL, ...]
 "CLAUSENAME.max_nok" => 0,

=item * C<|> suffix (multiple clause values, only one must succeed)

 "CLAUSENAME|" => [VAL, ...]

is equivalent to:

 "CLAUSENAME.vals" => [VAL, ...],
 "CLAUSENAME.min_ok" => 1,

=item * C<!> prefix (negation)

 "!CLAUSENAME" => VAL

is a shortcut for this:

 CLAUSENAME => VAL,
 "CLAUSENAME.max_ok" => 0,

=item * C<=> suffix (expression)

 "CLAUSENAME=" => EXPR
 "CLAUSENAME.ATTRNAME1=" => EXPR

are equivalent to:

 "CLAUSENAME.expr" => EXPR
 "CLAUSENAME.ATTRNAME1.expr" => EXPR

=back

When doing validation, all clauses will be evaluated and must succeed if the
validation is to succeed. The order of evaluation usually does not matter, but
some clauses are early (like "default" and "prefilters") and some are late (like
"postfilters").

=head2 Clause name

This specification comes from DefHash: Clause names must begin with
letter/underscore and contain letters/numbers/underscores only. All clauses
which begin with an C<_> (underscore) is ignored. You can use this to embed
extra data for other purposes.

=head2 Clause attribute

This specification comes from DefHash: Attribute name must also only contain
letters/numbers/underscores, but it can be a dotted-separated series of parts,
e.g. C<alt.lang.id_ID>. As with clauses, clause attributes which begin with C<_>
(underscore) is ignored. You can use this to embed extra data.

Currently known attributes:

=over 4

=item * vals => ARRAY

This attribute can be used to store more than one values to a clause. Example:

 ['int*' => {"div_by.vals"=>[2, 3, 5]}]

The above schema requires an integer which is divisible by 2, 3, I<and> 5.

If this attribute is set, and the clause attribute is set, then all values from
both must pass the clause. For example, the previous schema can also be written
as:

 ['int*' => {div_by=>2, "div_by.vals"=>[3, 5]}]

=item * min_ok, max_ok, min_nok, max_nok => INT

In a clause when using multiple clause values, these attributes regulate the
{minimum, maximum} number of values that must {pass, fail} the check for the
whole clause to pass.

Analogously, in a clause set, these attributes regulate the {minimum, maximum}
number of clauses that must {pass, fail} the check for the whole clause set to
pass.

B<min_ok>'s default is undef. You can use this attribute to only require certain
number of (instead of all) passing checks.

Example:

 [str => {cset => {min_len=>8, match=>qr/\W/}, 'cset.min_ok'=>1}]

The above schema requires a string to be at least 8 characters long, B<or>
contains a non-word character. Strings that would validate include: C<abcdefgh>
or C<$> or C<$abcdefg>. Strings that would not validate include: C<abcd> (fails
both C<min_len> and C<match> clauses). Without the .min_ok attribute, by default
all checks in the B<cset> clause must pass.

Another example:

 [str => {'match.vals'=>[RE1, RE2, RE3], 'match.min_ok'=>2}]

The above schema specifies that string must match at least two of RE1/RE2/RE3.

B<max_ok>'s default is undef. You can use this attribute to require a number of
failures in the checks.

Example:

 ['str', min_len=>8, match=>qr/\W/, '.min_ok'=>1, '.max_ok'=>1]

The above schema states that string must either be longer than 8 characters or
contains a non-word character, I<but not both>. Strings that would validate
include: C<abcdefgh> or C<$>. Strings that would not validate include:
C<$abcdefg> (match both clauses, so max_ok is not satisfied).

Another example:

 [str => {'match.vals'=>[RE1, RE2, RE3], 'match.max_ok'=>1}]

The above schema specifies that string must not match more than one of
RE1/RE2/RE3.

B<min_nok>'s default is undef. You can use this attribute to require a certain
number of failures.

Example:

 [str => {cset=>{min_len=>8, match=>qr/\W/}, 'cset.min_nok'=>1}]

The above schema requires a string to be shorter than 8 characters or devoid of
non-word characters. Strings that would validate include: C<abcdefghi> (fails
the C<match> clause), C<$abcd> (fails C<min_len> clause), or C<a> (fails both
clauses). Strings that would not validate include: C<$abcdefg>.

Another example:

 [str => {'match.vals'=>[RE1, RE2, RE3], 'match.min_nok'=>1}]

The above schema specifies that string must fail at least one regex match.

B<max_nok>'s default is undef, but when none of the {min,max}_{ok,nok} is
defined, the default behavior is to require all clauses to succeed, in other
words, as if C<max_nok> were 0. You can use this clause to tolerate a certain
number of failures in the checks.

Example:

 [str => {cset=>{min_len=>8, match=>qr/\W/}, 'cset.max_nok'=>1}]

The above schema states that string must either be longer than 8 characters or
contains two non-word characters, I<or both>. Strings that would validate
include: C<abcdefgh>, C<$$>, C<$abcdefgh>. Strings that would not validate
include: C<abcd> (fails both C<min_len> and C<match> clauses).

Another example:

 [str => {'match.vals'=>[RE1, RE2, RE3], 'match.max_nok'=>1}]

The above schema specifies that string can fail at most one regex match.

=item * expr => STR

Can be used for clause or another attribute to indicate that the value is not a
literal, but an expression. Example:

 # a string, minimum 4 characters
 [str => {min_len => 4}]

 # same thing, albeit a bit fancier
 [str => {'min_len=' => '2*2'}]

 # for default, we pick a random number between 1 and 10
 [int => {'default=' => 'int(10*rand())+1'}],

Expression is useful for more complex schema, when a clause/attribute value
needs to be calculated in terms of other values, and/or using functions.

Note that not all clause or attribute support expression.

=item * err_level => STR (default: error)

Valid value: C<error>, C<warn>. Normally, when clause checking fails, an error
is generated and it causes validation of the whole schema to fail. If
B<err_level> is set to C<warn>, however, this only generates a warning and does
not cause the validation to fail.

 # password
 ['str*' => {'cset&' => [
   {min_len             => 4},
   {min_len             => 8,
    "min_len.err_level" => "warn",
    "min_len.err_msg"   => "Although a password less than 8 letters are ".
                           "valid it's highly recommended that a password is ".
                           "at least 8 letters long, for security reasons"},
 ]}],

In the above example, the C<err_level> and C<err_msg> are attributes for the
C<min_len> clause. The second clause set basically adds an optional restriction
for the password: when the C<min_len> clause is not satisfied, instead of making
the data fails the validation, only a warning is issued.

=item * err_msg[.LANGCODE]

This tells the compiler that instead of the default error message from the type
handler, a custom error message is supplied. You can add translations by adding
more attributes. For example:

 [str=>{match                  => qr/[^A-Za-z0-9_-]/,
        'match.err_msg'        => 'Must not contain naughty characters',
        'match.err_msg.id_ID'  => 'Tidak boleh mengandung karakter aneh-aneh',
 }]

=item * human[.LANGCODE]

This is also ignored when validating data, but will be used by the human
compiler to supply description. You can add translations by adding more
attributes.

 [str=>{match               => qr/[^A-Za-z0-9_-]/,
        'match.human'       => 'Must not contain naughty characters',
        'match.human.id_ID' => 'Tidak boleh mengandung karakter aneh-aneh',
 }]

=item * alt

This comes from DefHash, mainly used to store translations for B<name>,
B<summary>, B<description>.

=item * result_var => VARNAME (EXPERIMENTAL)

Specify variable name to store results in.

Aside from pass/failure, a clause or clause set can also produce some value.
This attribute specifies where to put the results in. The value can then be
used by referring to the variable in expression. Example:

 [any => {
     of => [
         ['str*'   => {min_len=>1, max_len=>10}], # 0
         ['str*'   => {min_len=>11}],             # 1
         ['array*' => {}],                        # 2
         ['hash*'  => {}],                        # 3
     ],
    'of.result_var' => 'a',
 }]

Aside from passing/failing the validation, the C<of> clause above also produces
an index to the schema in the list which matches. So if you validate an array,
C<$a> in the schema will be set to 2. If you validate a string with length 12,
C<$a> will be set to 1. If you pass an empty string (which does not pass the
C<of> clause, C<$a> will not be set.

Refer to each clause's documentation to find out what value the clause returns.

=back

=head2 Clause set merging

Clause set merging happens when a schema is based on another schema and the
child schema's clause set contains merge prefixes (explained later) in its keys.
For example:

 # schema1
 [TYPE1 => CSET1]

 # schema2, based on schema1
 [schema1 => CSET2]

 # schema3, based on schema2
 [schema2 => CSET3]

When compiling/evaluating C<schema2>, Sah will check against C<TYPE1> and
C<CSET1> and then C<CSET2>. However, when C<CSET2> contains a merge prefix
(marked with an asterisk here for illustration), then Sah will check against
C<TYPE1> and C<< merge(CSET1, *CSET2) >>.

When compiling/evaluating C<schema3>, Sah will check against C<TYPE1> and
C<CSET1> and then C<CSET2> and then C<CSET3>. However, when C<CSET2> contains a
merge prefix, then Sah will check against C<TYPE1>, C<< merge(CSET1, *CSET2) >>,
and then C<CSET3>. When C<CSET2> and C<CSET3> contains merge prefixes, Sah will
check against C<TYPE1> and C<< merge(CSET1, *CSET2, *CSET3) >>. So merging will
be done from left to right.

The base schema's clause set must not contain any merge prefixes.

Merging is done using L<Data::ModeMerge>, with merge prefixes changed to
'[merge+]', '[merge!]' and so on. In merging, Data::ModeMerge allows keys on the
right side hash not only to replace but also add, subtract, remove keys from the
left side. This is powerful because it allows schema definition to not only add
clauses (restrict types even more), but also replace clauses (change type
restriction) as well as delete clauses (relax type restriction). For more
information, refer to the Data::ModeMerge documentation.

Illustration:

 int + {div_by=>2} + {  div_by =>3}            # must be divisible by 2 & 3

 int + {div_by=>2} + {'[merge]div_by'=>3}      # will be merged and become:
 int + {div_by=>3}                             # must be divisible by 3 ONLY

 int + {div_by=>2} + {'[merge!]div_by'=>0}     # will be merged and become:
 int + {}                                      # need not be divisible by any

 int + {in=>[1,2,3,4,5]} + {  in =>[6]}        # impossible to satisfy

 int + {in=>[1,2,3,4,5]} + {'[merge+]in'=>[6]} # will be merged and become:
 int + {in=>[1,2,3,4,5,6]}

 int + {in=>[1,2,3,4,5]}, {'-in'=>[4]}         # will be merged and become:
 int + {in=>[1,2,3,  5]}

Merging is performed before schema is normalized.

Merging is not recursive.


=head1 EXPRESSION

XXX: Syntax of variables not yet fixed.

Sah supports expressions, using L<Language::Expr> minilanguage. See
L<Language::Expr::Manual::Syntax> for details on the syntax. You can specify
expression in the B<check> clause, e.g.:

 [int => {check => '$_ >= 4'}]

Alternatively, expression can also be specified in any clause's attribute:

 [int => {'min='     => '2+2'}]
 [int => {'min.val=' => 'floor(4.9)'}]

The above three schemas are equivalent to:

 [int => {min => 4}]

Expression can refer to elements of data and (normalized) schema, and can call
functions, enabling more complex schema to be defined, for example:

 ['array*' => {len=>2, elems => [
   ['str*', {match => '^\w+$'}],
   ['str*', {'match=' => '${../../0/clause_sets/0/match}',
             'min_len=' => '2*length(${data:../0})'}]
 ]}]

The above schema requires data to be a two-element array containing strings,
where the length of the second string has to be at least twice the length of the
first. Both strings have to comply to the same regex, qr/^\w+$/ (which is
declared on the first string's clause and referred to in the second string's
clause).


=head1 FUNCTION

Functions can be used in expressions. The syntax of calling function is:

 func()
 func(ARG, ...)

Functions in Sah can sometimes accept several types of arguments, e.g.
length(ARRAY) will return the number of elements in the ARRAY, while length(STR)
will return the number of characters in the string. However, when an
inappropriate argument is given, a Perl exception will be thrown.


=head1 HISTORY

2012-07-21 split specification to Sah

2011-11-23 Data::Sah

2009-03-30 Data::Schema (first CPAN release)

Previous incarnation as Schema-Nested (internal)


=head1 SEE ALSO

L<DefHash>

L<Sah::Type>, L<Sah::FAQ>

=cut
