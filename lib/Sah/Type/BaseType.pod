package Sah::Type::BaseType; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Specification for the base type

=head1 DESCRIPTION

All Sah types should derive from BaseType.


=head1 CLAUSES

The list below is ordered by priority, from highest to lowest.

=head2 v => INT (default: 1)

Specify schema version. Should be C<1> at the moment. See also: L<DefHash>.

Priority: 0 (checked first before everything else).

=head2 default => ANY

Supply a default value.

Priority: 1 (very high). This is processed before all other clauses.

Example: Given schema [int => {req=>1}] an undef data is invalid, but given
schema [int => {req=>1, default=>3}] an undef data is valid because it will be
given default value first.

=head2 default_lang => LOCALE_CODE (defaut: en_US)

Set default language for this schema. Language-dependant attribute values (e.g.
C<summary>, C<description>) will be assumed to be in the default language. See
also: L<DefHash>.

Priority: 2 (very high), after C<default>.

=head2 name => STR

A short (usually single-word, without any formatting) to name the schema, useful
for identifying the schema when used as a type for human compiler. See also:
L<DefHash>.

To store translations, you can use the C<alt.lang.*> clause attributes.

Example:

 [int => {
     'name:alt.lang.en_US' => 'pos_int',
     'name:alt.lang.id_ID' => 'bil_pos',
     min=>0,
 }]

Priority: 2 (very high), after C<default>.

See also: C<summary>, C<description>, C<tags>.

=head2 summary => STR

A one-line text (about 72 characters maximum, without any formatting) to
describe the schema. This is useful, e.g. for manually describe a schema instead
of using the human compiler. It can also be used in form field labels. See also:
L<DefHash>.

To store translations, you can use the C<alt.lang.*> clause attributes.

Example:

 # definition for 'single_dice_throw' schema/type
 [int => {
     req => 1,
     'summary:alt.lang.en_US' =>
         'A number representing result of single dice throw (1-6)',
     'summary:alt.lang.id_ID' =>
         'Bilangan yang menyatakan hasil lempar sebuah dadu (1-6)',
     between => [1, 6],
 }]

Using the human compiler, the above schema will be output as the standard, more
boring 'Integer, value between 1 and 6.'

Priority: 2 (very high), after C<default>.

See also: C<name>, C<description>, C<tags>.

=head2 description => STR

A longer text (a paragraph or more) to describe the schema, useful e.g. for
help/usage text. Text should be in Markdown format. See also: L<DefHash>.

To store translations, you can use the C<alt.lang.*> clause attributes.

Example:

 [array => {
     name        => 'http_headers',
     description => <<EOT,
 HTTP headers should be specified as an array of 2-element arrays (pairs). Each
 pair should contain header name in the first element (all lowercase, *-*
 written as *_*) and header value in the second element.

 Example:

 : [[content_type => 'text/html'], [accept => 'text/html'], [accept => '*/*']]

 EOT
     req => 1,
     of  => 'http_header',
  },
  {
      def => {
          http_header => ['array*', len=>2],
      },
 }]

Priority: 2 (very high), after C<default>.

See also: C<name>, C<summary>, C<tags>.

=head2 tags => ARRAY OF STR

A list of tags, can be used to categorize schemas. See also: L<DefHash>.

Priority: 2 (very high), after C<default>.

See also: C<name>, C<summary>, C<description>.

=head2 req => BOOL

If set to 1, require that data be defined. Otherwise, allow data to be undef
(the default behaviour).

Priority: 3 (very high), executed after C<default>.

By default, undef will pass even elaborate schema, e.g. [int => {min=>0,
max=>10, div_by=>3}] will still pass an undef. However, undef will not pass
[int=>{req=>1}].

This behaviour is much like NULLs in SQL: we *can't* (in)validate something that
is unknown/unset.

See also: C<forbidden>

=head2 forbidden => BOOL

This is the opposite of C<req>, requiring that data be not defined (i.e. undef).

Priority: 3 (very high), executed after C<default>.

Given schema [int=>{forbidden=>1}], a non-undef value will fail. Another
example: the schema [int=>{req=>1, forbidden=>1}] will always fail due to
conflicting clauses.

See also: C<req>

=head2 prefilters => [EXPR, ...]

Run expression(s), usually to preprocess data before further checking. Data is
referred to in expression by variable C<$_>. Prefiltered value should persist
until the end of all other clauses (until the end of clause set), after which
the old value can be restored.

Priority: 10 (high). Run after C<default> and C<req>/C<forbidden>.

Specific attributes: C<perm>. If set to true, then prefiltered value will
persist.

=head2 noop => ANY

Will do nothing. This clause is just a convenience if you want to do nothing (or
perhaps just use the attributes of this clause to do things).

Priority: 50 (normal)

=head2 fail => BOOL

If set to 1, validation of this clause always fails. This is just a convenience
to force failure.

Priority: 50 (normal)

=head2 cset => HASH

Evaluate a clause set.

Priority: 50 (normal)

=head2 if => [CLAUSE1=>VAL, CLAUSE2=>VAL] or [CLAUSE_SET(S)1, CLAUSE_SET(S)2]

There are two forms of the C<if> clause. The first form (4-argument) is used to
state that if CLAUSE1 succeeds, then CLAUSE2 must also succeed. The second form
(2-argument) operates on a clause set (hash) or clause sets (array of hashes).

Examples:

 # leap year
 [int => {div_by=>4, if => [div_by => 100, div_by => 400]}]

The C<if> clause states that if input number is divisible by 100, it must also
divisible by 400. Otherwise, the clause fails.

 [str => {min_len=>1, max_len=>10,
          if => [ {min_len=>4, max_len=>6}, {is_palindrome=>1} ]}]

The above says that if a string has length between 4 and 6 then it must be a
palindrome. Otherwise it doesn't have to be one. But nevertheless, all input
must be between 1 and 10 characters long.

 [str => {if => [ [{match=>'a'}, {match=>'b'}],
                  [{match=>'c'}, {match=>'d'}] ]}]

The above says that if a string matches 'a' and 'b', it must also match 'c' and
'd'. As a side note, the above schema can also be written as:

 [str => {if => [ 'match&'=>['a', 'b'], 'match&'=>['c', 'd'] ]}]

=head2 check => EXPR

Evaluate expression, which must evaluate to a true value for this clause to
succeed.

Priority: 50 (normal)

=head2 postfilters => [EXPR, ...]

Run expression(s), usually to postprocess data. Data is referred to in
expression by variable C<$_>. From here on, the data will be permanently set to
the postfiltered value.

Priority: 90 (very low). Run after all other clauses.


=head1 SEE ALSO

L<Sah>

=cut
