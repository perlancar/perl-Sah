package Sah::Examples; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Examples

=head1 SIMPLE SCHEMAS

 # integer, optional
 'int'

 # required integer
 'int*'

 # same thing
 ['int', {req=>1}]

 # integer between 1 and 10
 ['int*', {min=>1, max=>10}]

 # same thing, the curly brace is optional (unless for advanced stuff)
 ['int*', min=>1, max=>10]

 # array of integers between 1 and 10
 ['array*', {of=>['int*', between=>[1, 10]]}]

 # a byte (let's assign it to a new type 'byte')
 ['int', {between=>[0,255]}]

 # a byte that's divisible by 3
 ['byte', {div_by=>3}]

 # a byte that's divisible by 3 *and* 5
 ['byte', {'div_by&'=>[3, 5]}]

 # a byte that's divisible by 3 *or* 5
 ['byte', {'div_by|'=>[3, 5]}]

 # a byte that's *in*divisible by 3
 ['byte', {'!div_by'=>3}]


=head1 CLAUSE ATTRIBUTES


=head1 EXPRESSIONS


=head1 FUNCTIONS


=head1 MERGING

=head2 Address

 # an address hash (let's assign it to a new type called 'address')
 ['hash' => {
     # recognized keys
     keys         => {
         line1        => ['str*', max_len => 80],
         line2        => ['str*', max_len => 80],
         city         => ['str*', max_len => 60],
         province     => ['str*', max_len => 60],
         postcode     => ['str*', len_between=>[4, 15], match=>'^[\w-]{4,15}$'],
         country      => ['str*', len => 2, match => '^[A-Z][A-Z]$'],
     },
     # keys that must exist in data
     req_keys     => [qw/line1 city province postcode country/],
  }]

  # a US address, let's base it on 'address' but change 'postcode' to 'zipcode'.
  # also, require country to be set to 'US'
  ['address' => {
      'merge.subtract.keys' => {postcode=>undef},
      'merge.normal.keys' => {
          zipcode => ['str*', len=>5, '^\d{5}$'],
          country => ['str*', is=>'US'],
      },
      'merge.subtract.req_keys' => [qw/postcode/],
      'merge.add.req_keys' => [qw/zipcode/],
  }]

